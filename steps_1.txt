* Open anaconda prompt 

*cd C:\Users\Dell\Desktop\data\science\ds\end 2 end project 2 
go to ur desired folder

*code .
this will open vscode instance of that folder location

*open terminal and type conda create -p venv python==3.8 -y 
y means default yes if asks for permission

*conda activate venv/ 
now we are inside the venv env

                                                        BASIC GIT COMMAND IN SAME TERMINAL

*git init

*git add README.md for adding file

*git commit -m "first commit" commiting

*git status

*git branch -m main 

*git remote add origin https://github.com/Chiga36/mlproject.git

*git remote -v

*git push -u origin main

*git pull
for pulling the things which are present in github but not in the local environment

*pip install -r requirements.txt
setup.py is linked with requirements.txt so installing requirements.txt will also install the setup.py

Q -> what is setup.py and egg-info and why do we need to setup this with requrements.txt explain me in a lay man terms
Let's break down these concepts in simple terms:

1. setup.py
What it is: A script used to define and package your Python project.

Why it exists:

It tells Python, "Here’s how to install/package my code."

It lists basic info like your project’s name, version, dependencies (install_requires), and what files to include.

Example use case:
If you share your project as a library (e.g., on PyPI), others can run pip install your-package, and setup.py ensures dependencies are installed automatically.

2. egg-info (or .dist-info)
What it is: A folder generated by setup.py that contains metadata about your package (like its name, version, and dependencies).

Why it exists:

Python uses this info to track what’s installed (e.g., for pip list or pip uninstall).

Created when you run commands like python setup.py develop or pip install.

3. requirements.txt
What it is: A plain text file listing exact versions of dependencies for your project.

Why it exists:

For developers to recreate the exact same environment (e.g., pip install -r requirements.txt).

Often includes everything needed (development tools, testing libraries, etc.), not just the minimum required to run the project.

Key Differences:
setup.py (for packaging)	requirements.txt (for development)
Purpose	Define package metadata + dependencies	Pin exact dependency versions
Audience	Users installing your library	Developers working on the project
Dependencies	Minimum versions (install_requires)	Exact versions (e.g., numpy==1.21.0)
Example Workflow:
As a library author:

Use setup.py to declare your package’s core dependencies (install_requires).

Use requirements.txt to lock versions for development/testing (e.g., pytest==7.0.0).

As a user:

Install your library with pip install your-package → setup.py ensures core dependencies are installed.

As a developer:

Run pip install -r requirements.txt to get the exact versions for development.

Why Both?
setup.py ensures your package works when others depend on it.

requirements.txt ensures consistency for collaborators (e.g., avoiding version conflicts).

Think of setup.py as “what my project needs to run” and requirements.txt as “what my team needs to develop/test it.” 🐍📦

Q -> give me an example where a developer name Shang needs it
Let’s imagine Shang, a developer building a Python library called weather-utils that fetches weather data from an API. Here’s how he’d use setup.py, egg-info, and requirements.txt:

Scenario 1: Shang Creates the Library
Goal: Let users install weather-utils as a reusable package.

setup.py (Defines the package):
Shang writes this file to specify:

The package name (weather-utils).

Dependencies (requests library to call APIs).

What code/files to include.

python
Copy
# setup.py
from setuptools import setup

setup(
    name="weather-utils",
    version="1.0.0",
    install_requires=["requests"],  # Core dependency
    packages=["weather_utils"],
)
Testing locally:
Shang runs:

bash
Copy
pip install -e .  # Install in "editable" mode for development
This:

Installs weather-utils as a package.

Generates egg-info (metadata like name, version, dependencies).

Now he can import weather_utils anywhere on his system!

Scenario 2: Shang Shares the Library
Goal: Users install weather-utils and its core dependencies.

A user runs:

bash
Copy
pip install weather-utils
Python reads setup.py and automatically installs requests (no extra work for the user).

egg-info is created on the user’s machine to track the installed package.

Scenario 3: Shang’s Development Team
Goal: Ensure all developers use the exact same versions of tools/dependencies.

requirements.txt (For development):
Shang lists:

Exact versions of requests (to avoid bugs from updates).

Testing tools (pytest).

Linting tools (flake8).

text
Copy
# requirements.txt
requests==2.28.1  # Exact version
pytest==7.2.0     # Only needed for testing
flake8==6.0.0     # Only needed for code quality checks
New developer joins the team:
They run:

bash
Copy
pip install -r requirements.txt
Now everyone has the exact same setup for development.

Key Takeaways for Shang:
setup.py: Defines the package and core dependencies (what users need).

egg-info: Auto-generated metadata (no need to touch this).

requirements.txt: Locks versions for developers (tests, tools, exact versions).

Without these:

Users might miss dependencies when installing weather-utils.

Developers could have version conflicts (e.g., pytest behaves differently for everyone).

Visual Workflow:
Copy
Shang’s Code → setup.py → Users: "pip install" works!  
                │  
                └→ requirements.txt → Team: "pip install -r" ensures consistency!  